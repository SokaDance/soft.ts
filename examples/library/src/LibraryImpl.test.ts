// Code generated by soft.generator.ts. DO NOT EDIT.

// *****************************************************************************
// Copyright(c) 2024 MASA Group
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
//
// *****************************************************************************

import { describe, expect, test } from "vitest"
import deepEqual from "deep-equal"
import { anything, capture, instance, mock, reset, verify, when } from "ts-mockito"
import * as ecore from "@masagroup/ecore"
import {
    Addressable,
    Book,
    Borrower,
    Employee,
    Item,
    Library,
    LibraryConstants,
    LibraryImpl,
    Person,
    Writer,
    getLibraryPackage
} from "./internal.js"

interface BookInternal extends Book, ecore.EObjectInternal {}
interface BorrowerInternal extends Borrower, ecore.EObjectInternal {}
interface EmployeeInternal extends Employee, ecore.EObjectInternal {}
interface ItemInternal extends Item, ecore.EObjectInternal {}
interface LibraryInternal extends Library, ecore.EObjectInternal {}
interface PersonInternal extends Person, ecore.EObjectInternal {}
interface WriterInternal extends Writer, ecore.EObjectInternal {}

describe("LibraryImpl", () => {
    test("eStaticClass", () => {
        const o = new LibraryImpl()
        expect(o.eStaticClass()).toBe(getLibraryPackage().getLibrary())
    })

    test("getAddress", () => {
        const o = new LibraryImpl()
        // get default value
        expect(o.address).toBe("")
    })

    test("setAddress", () => {
        const o = new LibraryImpl()
        const value = "Test String"

        // add listener
        const mockAdapter = mock<ecore.EAdapter>()
        const adapter = instance(mockAdapter)
        o.eAdapters().add(adapter)

        // set value
        o.address = value

        // checks
        verify(mockAdapter.notifyChanged(anything())).once()
        const [notification] = capture(mockAdapter.notifyChanged).last()
        expect(notification.getNotifier()).toBe(o)
        expect(notification.getOldValue()).toBe("")
        expect(notification.getNewValue()).toBe(value)
        expect(notification.getPosition()).toBe(-1)
    })

    test("getBooks", () => {
        const o = new LibraryImpl()
        expect(o.books).not.toBeNull()
    })

    test("getBorrowers", () => {
        const o = new LibraryImpl()
        expect(o.borrowers).not.toBeNull()
    })

    test("getBranches", () => {
        const o = new LibraryImpl()
        expect(o.branches).not.toBeNull()
    })

    test("getEmployees", () => {
        const o = new LibraryImpl()
        expect(o.employees).not.toBeNull()
    })

    test("getName", () => {
        const o = new LibraryImpl()
        // get default value
        expect(o.name).toBe("")
    })

    test("setName", () => {
        const o = new LibraryImpl()
        const value = "Test String"

        // add listener
        const mockAdapter = mock<ecore.EAdapter>()
        const adapter = instance(mockAdapter)
        o.eAdapters().add(adapter)

        // set value
        o.name = value

        // checks
        verify(mockAdapter.notifyChanged(anything())).once()
        const [notification] = capture(mockAdapter.notifyChanged).last()
        expect(notification.getNotifier()).toBe(o)
        expect(notification.getOldValue()).toBe("")
        expect(notification.getNewValue()).toBe(value)
        expect(notification.getPosition()).toBe(-1)
    })

    test("getParentBranch", () => {
        // default
        const o = new LibraryImpl()
        expect(o.parentBranch).toBeNull()

        // set a mock container
        const mockContainer = mock<ecore.EObject>()
        const container = instance(mockContainer)
        o.eSetInternalContainer(container, LibraryConstants.LIBRARY__PARENT_BRANCH)

        // no proxy
        when(mockContainer.eIsProxy()).thenReturn(false)
        expect(o.parentBranch).toBe(container)
        verify(mockContainer.eIsProxy()).once()
    })

    test("setParentBranch", () => {
        const o = new LibraryImpl()
        const mockResource = mock<ecore.EResource>()
        const resource = instance(mockResource)
        const mockValue = mock<LibraryInternal>()
        const value = instance(mockValue)

        // add listener
        const mockAdapter = mock<ecore.EAdapter>()
        const adapter = instance(mockAdapter)
        o.eAdapters().add(adapter)

        // set value
        when(mockValue.eInverseAdd(o, LibraryConstants.LIBRARY__BRANCHES, null)).thenReturn(null)
        when(mockValue.eResource()).thenReturn(resource)
        o.parentBranch = value
        verify(mockResource.attached(o)).once()
        verify(mockAdapter.notifyChanged(anything())).once()
        {
            const [notification] = capture(mockAdapter.notifyChanged).last()
            expect(notification.getNotifier()).toBe(o)
            expect(notification.getOldValue()).toBeNull()
            expect(notification.getNewValue()).toBe(value)
        }
        // set with the same value
        reset(mockAdapter)
        o.parentBranch = value
        verify(mockAdapter.notifyChanged(anything())).once()

        // set with another value in a different resource
        const mockOther = mock<LibraryInternal>()
        const other = instance(mockOther)
        const mockOtherResource = mock<ecore.EResource>()
        const otherResource = instance(mockOtherResource)
        reset(mockAdapter)
        reset(mockValue)
        reset(mockResource)
        when(mockValue.eInverseRemove(o, LibraryConstants.LIBRARY__BRANCHES, null)).thenReturn(null)
        when(mockValue.eResource()).thenReturn(resource)
        when(mockOther.eInverseAdd(o, LibraryConstants.LIBRARY__BRANCHES, null)).thenReturn(null)
        when(mockOther.eResource()).thenReturn(otherResource)
        o.parentBranch = other
        verify(mockResource.detached(o)).once()
        verify(mockOtherResource.attached(o)).once()
        verify(mockAdapter.notifyChanged(anything())).once()
        {
            const [notification] = capture(mockAdapter.notifyChanged).last()
            expect(notification.getNotifier()).toBe(o)
            expect(notification.getOldValue()).toBe(value)
            expect(notification.getNewValue()).toBe(other)
            expect(notification.getPosition()).toBe(-1)
        }
    })

    test("basicSetParentBranch", () => {
        const o = new LibraryImpl()
        const mockValue = mock<LibraryInternal>()
        const value = instance(mockValue)

        // add listener
        const mockAdapter = mock<ecore.EAdapter>()
        const adapter = instance(mockAdapter)
        o.eAdapters().add(adapter)

        // notification chain
        const mockNotifications = mock<ecore.ENotificationChain>()
        const notifications = instance(mockNotifications)

        // set value
        when(mockValue.eResource()).thenReturn(null)
        when(mockNotifications.add(anything())).thenReturn(true)
        o.basicSetParentBranch(value, notifications)

        // checks
        verify(mockNotifications.add(anything())).once()
        const [notification] = capture(mockNotifications.add).last()
        expect(notification.getNotifier()).toBe(o)
        expect(notification.getEventType()).toBe(ecore.EventType.SET)
        expect(notification.getFeatureID()).toBe(LibraryConstants.LIBRARY__PARENT_BRANCH)
        expect(notification.getOldValue()).toBeNull()
        expect(notification.getNewValue()).toBe(value)
        expect(notification.getPosition()).toBe(-1)
    })

    test("getPeople", () => {
        const o = new LibraryImpl()
        expect(o.people).toBeNull()
    })

    test("getProprietary", () => {
        const o = new LibraryImpl()

        // get default value
        expect(o.proprietary).toBeNull()
    })

    test("setProprietary", () => {
        const o = new LibraryImpl()
        const mockValue = mock<PersonInternal>()
        const value = instance(mockValue)

        // add listener
        const mockAdapter = mock<ecore.EAdapter>()
        const adapter = instance(mockAdapter)
        o.eAdapters().add(adapter)

        // set value
        o.proprietary = value

        // checks
        verify(mockAdapter.notifyChanged(anything())).once()
        const [notification] = capture(mockAdapter.notifyChanged).last()
        expect(notification.getNotifier()).toBe(o)
        expect(notification.getOldValue()).toBeNull()
        expect(notification.getNewValue()).toBe(value)
        expect(notification.getPosition()).toBe(-1)
    })

    test("basicSetProprietary", () => {
        const o = new LibraryImpl()
        const mockValue = mock<PersonInternal>()
        const value = instance(mockValue)

        // add listener
        const mockAdapter = mock<ecore.EAdapter>()
        const adapter = instance(mockAdapter)
        o.eAdapters().add(adapter)

        // notification chain
        const mockNotifications = mock<ecore.ENotificationChain>()
        const notifications = instance(mockNotifications)

        // set value
        when(mockNotifications.add(anything())).thenReturn(true)
        o.basicSetProprietary(value, notifications)

        // checks
        verify(mockNotifications.add(anything())).once()
        const [notification] = capture(mockNotifications.add).last()
        expect(notification.getNotifier()).toBe(o)
        expect(notification.getEventType()).toBe(ecore.EventType.SET)
        expect(notification.getFeatureID()).toBe(LibraryConstants.LIBRARY__PROPRIETARY)
        expect(notification.getOldValue()).toBeNull()
        expect(notification.getNewValue()).toBe(value)
        expect(notification.getPosition()).toBe(-1)
    })

    test("getStock", () => {
        const o = new LibraryImpl()
        expect(o.stock).not.toBeNull()
    })

    test("getWriters", () => {
        const o = new LibraryImpl()
        expect(o.writers).not.toBeNull()
    })

    test("eGetFromID", () => {
        const o = new LibraryImpl()
        expect(() => o.eGetFromID(-1, true)).toThrow(Error)
        expect(o.eGetFromID(LibraryConstants.LIBRARY__ADDRESS, true)).toStrictEqual(o.address)
        expect(o.eGetFromID(LibraryConstants.LIBRARY__BOOKS, true)).toStrictEqual(o.books)
        expect(
            deepEqual(
                o.eGetFromID(LibraryConstants.LIBRARY__BOOKS, false),
                (o.books as ecore.EObjectList<Book>).getUnResolvedList()
            )
        ).toBeTruthy()
        expect(o.eGetFromID(LibraryConstants.LIBRARY__BORROWERS, true)).toStrictEqual(o.borrowers)
        expect(
            deepEqual(
                o.eGetFromID(LibraryConstants.LIBRARY__BORROWERS, false),
                (o.borrowers as ecore.EObjectList<Borrower>).getUnResolvedList()
            )
        ).toBeTruthy()
        expect(o.eGetFromID(LibraryConstants.LIBRARY__BRANCHES, true)).toStrictEqual(o.branches)
        expect(
            deepEqual(
                o.eGetFromID(LibraryConstants.LIBRARY__BRANCHES, false),
                (o.branches as ecore.EObjectList<Library>).getUnResolvedList()
            )
        ).toBeTruthy()
        expect(o.eGetFromID(LibraryConstants.LIBRARY__EMPLOYEES, true)).toStrictEqual(o.employees)
        expect(
            deepEqual(
                o.eGetFromID(LibraryConstants.LIBRARY__EMPLOYEES, false),
                (o.employees as ecore.EObjectList<Employee>).getUnResolvedList()
            )
        ).toBeTruthy()
        expect(o.eGetFromID(LibraryConstants.LIBRARY__NAME, true)).toStrictEqual(o.name)
        expect(o.eGetFromID(LibraryConstants.LIBRARY__PARENT_BRANCH, true)).toStrictEqual(o.parentBranch)
        expect(o.eGetFromID(LibraryConstants.LIBRARY__PEOPLE, true)).toStrictEqual(o.people)
        expect(o.eGetFromID(LibraryConstants.LIBRARY__PROPRIETARY, true)).toStrictEqual(o.proprietary)
        expect(o.eGetFromID(LibraryConstants.LIBRARY__STOCK, true)).toStrictEqual(o.stock)
        expect(
            deepEqual(
                o.eGetFromID(LibraryConstants.LIBRARY__STOCK, false),
                (o.stock as ecore.EObjectList<Item>).getUnResolvedList()
            )
        ).toBeTruthy()
        expect(o.eGetFromID(LibraryConstants.LIBRARY__WRITERS, true)).toStrictEqual(o.writers)
        expect(
            deepEqual(
                o.eGetFromID(LibraryConstants.LIBRARY__WRITERS, false),
                (o.writers as ecore.EObjectList<Writer>).getUnResolvedList()
            )
        ).toBeTruthy()
    })

    test("eSetFromID", () => {
        const o = new LibraryImpl()
        expect(() => o.eSetFromID(-1, null)).toThrow(Error)
        {
            const value = "Test String"
            o.eSetFromID(LibraryConstants.LIBRARY__ADDRESS, value)
            expect(o.eGetFromID(LibraryConstants.LIBRARY__ADDRESS, false)).toBe(value)
        }
        {
            // list with a value
            const mockValue = mock<BookInternal>()
            const value = instance(mockValue)
            const l = new ecore.ImmutableEList<Book>([value])
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__BOOKS, anything())
            ).thenReturn(null)

            // set list with new contents
            o.eSetFromID(LibraryConstants.LIBRARY__BOOKS, l)
            // checks
            expect(o.books.size()).toBe(1)
            expect(o.books.get(0)).toBe(value)
            verify(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__BOOKS, anything())
            ).once()
        }

        {
            // list with a value
            const mockValue = mock<BorrowerInternal>()
            const value = instance(mockValue)
            const l = new ecore.ImmutableEList<Borrower>([value])
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__BORROWERS, anything())
            ).thenReturn(null)

            // set list with new contents
            o.eSetFromID(LibraryConstants.LIBRARY__BORROWERS, l)
            // checks
            expect(o.borrowers.size()).toBe(1)
            expect(o.borrowers.get(0)).toBe(value)
            verify(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__BORROWERS, anything())
            ).once()
        }

        {
            // list with a value
            const mockValue = mock<LibraryInternal>()
            const value = instance(mockValue)
            const l = new ecore.ImmutableEList<Library>([value])
            when(mockValue.eInverseAdd(o, LibraryConstants.LIBRARY__PARENT_BRANCH, anything())).thenReturn(null)

            // set list with new contents
            o.eSetFromID(LibraryConstants.LIBRARY__BRANCHES, l)
            // checks
            expect(o.branches.size()).toBe(1)
            expect(o.branches.get(0)).toBe(value)
            verify(mockValue.eInverseAdd(o, LibraryConstants.LIBRARY__PARENT_BRANCH, anything())).once()
        }

        {
            // list with a value
            const mockValue = mock<EmployeeInternal>()
            const value = instance(mockValue)
            const l = new ecore.ImmutableEList<Employee>([value])
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__EMPLOYEES, anything())
            ).thenReturn(null)

            // set list with new contents
            o.eSetFromID(LibraryConstants.LIBRARY__EMPLOYEES, l)
            // checks
            expect(o.employees.size()).toBe(1)
            expect(o.employees.get(0)).toBe(value)
            verify(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__EMPLOYEES, anything())
            ).once()
        }

        {
            const value = "Test String"
            o.eSetFromID(LibraryConstants.LIBRARY__NAME, value)
            expect(o.eGetFromID(LibraryConstants.LIBRARY__NAME, false)).toBe(value)
        }
        {
            const mockValue = mock<LibraryInternal>()
            const value = instance(mockValue)
            when(mockValue.eIsProxy()).thenReturn(false)
            when(mockValue.eResource()).thenReturn(null)
            when(mockValue.eInverseAdd(o, LibraryConstants.LIBRARY__BRANCHES, null)).thenReturn(null)
            o.eSetFromID(LibraryConstants.LIBRARY__PARENT_BRANCH, value)
            expect(o.eGetFromID(LibraryConstants.LIBRARY__PARENT_BRANCH, false)).toBe(value)
            verify(mockValue.eIsProxy()).once()
            verify(mockValue.eResource()).once()
            verify(mockValue.eInverseAdd(o, LibraryConstants.LIBRARY__BRANCHES, null)).once()
        }
        {
            const mockValue = mock<PersonInternal>()
            const value = instance(mockValue)
            when(
                mockValue.eInverseAdd(
                    o,
                    ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__PROPRIETARY,
                    anything()
                )
            ).thenReturn(null)
            o.eSetFromID(LibraryConstants.LIBRARY__PROPRIETARY, value)
            expect(o.eGetFromID(LibraryConstants.LIBRARY__PROPRIETARY, false)).toBe(value)
            verify(
                mockValue.eInverseAdd(
                    o,
                    ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__PROPRIETARY,
                    anything()
                )
            ).once()
        }
        {
            // list with a value
            const mockValue = mock<ItemInternal>()
            const value = instance(mockValue)
            const l = new ecore.ImmutableEList<Item>([value])
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__STOCK, anything())
            ).thenReturn(null)

            // set list with new contents
            o.eSetFromID(LibraryConstants.LIBRARY__STOCK, l)
            // checks
            expect(o.stock.size()).toBe(1)
            expect(o.stock.get(0)).toBe(value)
            verify(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__STOCK, anything())
            ).once()
        }

        {
            // list with a value
            const mockValue = mock<WriterInternal>()
            const value = instance(mockValue)
            const l = new ecore.ImmutableEList<Writer>([value])
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__WRITERS, anything())
            ).thenReturn(null)

            // set list with new contents
            o.eSetFromID(LibraryConstants.LIBRARY__WRITERS, l)
            // checks
            expect(o.writers.size()).toBe(1)
            expect(o.writers.get(0)).toBe(value)
            verify(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__WRITERS, anything())
            ).once()
        }
    })

    test("eIsSetFromID", () => {
        const o = new LibraryImpl()
        expect(() => o.eIsSetFromID(-1)).toThrow(Error)
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__ADDRESS)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__BOOKS)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__BORROWERS)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__BRANCHES)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__EMPLOYEES)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__NAME)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__PARENT_BRANCH)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__PROPRIETARY)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__STOCK)).toBeFalsy()
        expect(o.eIsSetFromID(LibraryConstants.LIBRARY__WRITERS)).toBeFalsy()
    })

    test("eUnsetFromID", () => {
        const o = new LibraryImpl()
        expect(() => o.eUnsetFromID(-1)).toThrow(Error)
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__ADDRESS)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__ADDRESS, false)
            expect(v).toBe("")
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__BOOKS)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__BOOKS, false)
            expect(v).not.toBeNull()
            const l = v as ecore.EList<Book>
            expect(l.isEmpty()).toBeTruthy()
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__BORROWERS)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__BORROWERS, false)
            expect(v).not.toBeNull()
            const l = v as ecore.EList<Borrower>
            expect(l.isEmpty()).toBeTruthy()
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__BRANCHES)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__BRANCHES, false)
            expect(v).not.toBeNull()
            const l = v as ecore.EList<Library>
            expect(l.isEmpty()).toBeTruthy()
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__EMPLOYEES)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__EMPLOYEES, false)
            expect(v).not.toBeNull()
            const l = v as ecore.EList<Employee>
            expect(l.isEmpty()).toBeTruthy()
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__NAME)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__NAME, false)
            expect(v).toBe("")
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__PARENT_BRANCH)
            expect(o.eGetFromID(LibraryConstants.LIBRARY__PARENT_BRANCH, false)).toBeNull()
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__PROPRIETARY)
            expect(o.eGetFromID(LibraryConstants.LIBRARY__PROPRIETARY, false)).toBeNull()
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__STOCK)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__STOCK, false)
            expect(v).not.toBeNull()
            const l = v as ecore.EList<Item>
            expect(l.isEmpty()).toBeTruthy()
        }
        {
            o.eUnsetFromID(LibraryConstants.LIBRARY__WRITERS)
            const v = o.eGetFromID(LibraryConstants.LIBRARY__WRITERS, false)
            expect(v).not.toBeNull()
            const l = v as ecore.EList<Writer>
            expect(l.isEmpty()).toBeTruthy()
        }
    })

    test("eBasicInverseAdd", () => {
        const o = new LibraryImpl()
        {
            const mockObject = mock<ecore.EObject>()
            const object = instance(mockObject)
            const mockNotifications = mock<ecore.ENotificationChain>()
            const notifications = instance(mockNotifications)
            expect(o.eBasicInverseAdd(object, -1, notifications)).toBe(notifications)
        }
        {
            const mockValue = mock<LibraryInternal>()
            const value = instance(mockValue)
            o.eBasicInverseAdd(value, LibraryConstants.LIBRARY__BRANCHES, null)
            expect(o.branches.contains(value)).toBeTruthy()
        }
        {
            const mockValue = mock<LibraryInternal>()
            const value = instance(mockValue)
            when(mockValue.eResource()).thenReturn(null)
            when(mockValue.eIsProxy()).thenReturn(false)
            o.eBasicInverseAdd(value, LibraryConstants.LIBRARY__PARENT_BRANCH, null)
            expect(o.parentBranch).toBe(value)

            reset(mockValue)
            const mockOther = mock<LibraryInternal>()
            const other = instance(mockOther)
            when(mockOther.eResource()).thenReturn(null)
            when(mockOther.eIsProxy()).thenReturn(false)
            when(mockValue.eResource()).thenReturn(null)
            when(mockValue.eInverseRemove(o, LibraryConstants.LIBRARY__BRANCHES, null)).thenReturn(null)
            o.eBasicInverseAdd(other, LibraryConstants.LIBRARY__PARENT_BRANCH, null)
            expect(o.parentBranch).toBe(other)
        }
    })

    test("eBasicInverseRemove", () => {
        const o = new LibraryImpl()
        {
            const mockObject = mock<ecore.EObject>()
            const object = instance(mockObject)
            const mockNotifications = mock<ecore.ENotificationChain>()
            const notifications = instance(mockNotifications)
            expect(o.eBasicInverseRemove(object, -1, notifications)).toBe(notifications)
        }
        {
            // initialize list with a mock object
            const mockValue = mock<BookInternal>()
            const value = instance(mockValue)
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__BOOKS, anything())
            ).thenReturn(null)

            o.books.add(value)

            // basic inverse remove
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__BOOKS, null)

            // check it was removed
            expect(o.books.contains(value)).toBeFalsy()
        }
        {
            // initialize list with a mock object
            const mockValue = mock<BorrowerInternal>()
            const value = instance(mockValue)
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__BORROWERS, anything())
            ).thenReturn(null)

            o.borrowers.add(value)

            // basic inverse remove
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__BORROWERS, null)

            // check it was removed
            expect(o.borrowers.contains(value)).toBeFalsy()
        }
        {
            // initialize list with a mock object
            const mockValue = mock<LibraryInternal>()
            const value = instance(mockValue)
            when(mockValue.eInverseAdd(o, LibraryConstants.LIBRARY__PARENT_BRANCH, anything())).thenReturn(null)

            o.branches.add(value)

            // basic inverse remove
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__BRANCHES, null)

            // check it was removed
            expect(o.branches.contains(value)).toBeFalsy()
        }
        {
            // initialize list with a mock object
            const mockValue = mock<EmployeeInternal>()
            const value = instance(mockValue)
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__EMPLOYEES, anything())
            ).thenReturn(null)

            o.employees.add(value)

            // basic inverse remove
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__EMPLOYEES, null)

            // check it was removed
            expect(o.employees.contains(value)).toBeFalsy()
        }
        {
            const mockValue = mock<LibraryInternal>()
            const value = instance(mockValue)
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__PARENT_BRANCH, null)
        }
        {
            const mockValue = mock<PersonInternal>()
            const value = instance(mockValue)
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__PROPRIETARY, null)
        }
        {
            // initialize list with a mock object
            const mockValue = mock<ItemInternal>()
            const value = instance(mockValue)
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__STOCK, anything())
            ).thenReturn(null)

            o.stock.add(value)

            // basic inverse remove
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__STOCK, null)

            // check it was removed
            expect(o.stock.contains(value)).toBeFalsy()
        }
        {
            // initialize list with a mock object
            const mockValue = mock<WriterInternal>()
            const value = instance(mockValue)
            when(
                mockValue.eInverseAdd(o, ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.LIBRARY__WRITERS, anything())
            ).thenReturn(null)

            o.writers.add(value)

            // basic inverse remove
            o.eBasicInverseRemove(value, LibraryConstants.LIBRARY__WRITERS, null)

            // check it was removed
            expect(o.writers.contains(value)).toBeFalsy()
        }
    })
})
