// Code generated by soft.generator.ts. DO NOT EDIT.

// *****************************************************************************
// Copyright(c) 2024 MASA Group
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
//
// *****************************************************************************

import * as ecore from "@masagroup/ecore"
import { DocumentRoot, Library, LibraryConstants, getLibraryPackage } from "./internal.js"

export class DocumentRootImpl extends ecore.EObjectImpl implements DocumentRoot {
    protected _xMLNSPrefixMap: ecore.EMap<string, string>
    protected _library: Library
    protected _xSISchemaLocation: ecore.EMap<string, string>

    constructor() {
        super()
        this._library = null
        this._xMLNSPrefixMap = null
        this._xSISchemaLocation = null
    }

    eStaticClass(): ecore.EClass {
        return getLibraryPackage().getDocumentRoot()
    }

    // get the value of library
    get library(): Library {
        return this.getLibrary()
    }

    // set the value of library
    set library(newLibrary: Library) {
        this.setLibrary(newLibrary)
    }

    // get the value of xMLNSPrefixMap
    get xMLNSPrefixMap(): ecore.EMap<string, string> {
        return this.getXMLNSPrefixMap()
    }

    // set the value of xMLNSPrefixMap
    set xMLNSPrefixMap(newXMLNSPrefixMap: ecore.EMap<string, string>) {
        const l = this.getXMLNSPrefixMap()
        l.clear()
        l.addAll(newXMLNSPrefixMap)
    }

    // get the value of xSISchemaLocation
    get xSISchemaLocation(): ecore.EMap<string, string> {
        return this.getXSISchemaLocation()
    }

    // set the value of xSISchemaLocation
    set xSISchemaLocation(newXSISchemaLocation: ecore.EMap<string, string>) {
        const l = this.getXSISchemaLocation()
        l.clear()
        l.addAll(newXSISchemaLocation)
    }

    // get the value of library
    getLibrary(): Library {
        return this._library
    }

    // set the value of library
    setLibrary(newLibrary: Library): void {
        const oldLibrary = this._library
        if (newLibrary != oldLibrary) {
            let notifications: ecore.ENotificationChain = null
            if (ecore.isEObjectInternal(oldLibrary)) {
                notifications = oldLibrary.eInverseRemove(
                    this,
                    ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.DOCUMENT_ROOT__LIBRARY,
                    notifications
                )
            }
            if (ecore.isEObjectInternal(newLibrary)) {
                notifications = newLibrary.eInverseAdd(
                    this,
                    ecore.EOPPOSITE_FEATURE_BASE - LibraryConstants.DOCUMENT_ROOT__LIBRARY,
                    notifications
                )
            }
            notifications = this.basicSetLibrary(newLibrary, notifications)
            if (notifications != null) {
                notifications.dispatch()
            }
        }
    }

    basicSetLibrary(newLibrary: Library, msgs: ecore.ENotificationChain): ecore.ENotificationChain {
        const oldLibrary = this._library
        this._library = newLibrary
        let notifications = msgs
        if (this.eNotificationRequired()) {
            const notification = new ecore.Notification(
                this,
                ecore.EventType.SET,
                LibraryConstants.DOCUMENT_ROOT__LIBRARY,
                oldLibrary,
                newLibrary
            )
            if (notifications != null) {
                notifications.add(notification)
            } else {
                notifications = notification
            }
        }
        return notifications
    }

    // get the value of xMLNSPrefixMap
    getXMLNSPrefixMap(): ecore.EMap<string, string> {
        if (this._xMLNSPrefixMap == null) {
            this._xMLNSPrefixMap = new ecore.BasicEObjectMap<string, string>(
                ecore.getEcorePackage().getEStringToStringMapEntry()
            )
        }
        return this._xMLNSPrefixMap
    }

    // set the value of xMLNSPrefixMap
    setXMLNSPrefixMap(newXMLNSPrefixMap: ecore.EMap<string, string>) {
        const l = this.getXMLNSPrefixMap()
        l.clear()
        l.addAll(newXMLNSPrefixMap)
    }

    // get the value of xSISchemaLocation
    getXSISchemaLocation(): ecore.EMap<string, string> {
        if (this._xSISchemaLocation == null) {
            this._xSISchemaLocation = new ecore.BasicEObjectMap<string, string>(
                ecore.getEcorePackage().getEStringToStringMapEntry()
            )
        }
        return this._xSISchemaLocation
    }

    // set the value of xSISchemaLocation
    setXSISchemaLocation(newXSISchemaLocation: ecore.EMap<string, string>) {
        const l = this.getXSISchemaLocation()
        l.clear()
        l.addAll(newXSISchemaLocation)
    }

    eGetFromID(featureID: number, resolve: boolean): any {
        switch (featureID) {
            case LibraryConstants.DOCUMENT_ROOT__LIBRARY: {
                return this.getLibrary()
            }
            case LibraryConstants.DOCUMENT_ROOT__XMLNS_PREFIX_MAP: {
                return this.getXMLNSPrefixMap()
            }
            case LibraryConstants.DOCUMENT_ROOT__XSI_SCHEMA_LOCATION: {
                return this.getXSISchemaLocation()
            }
            default: {
                return super.eGetFromID(featureID, resolve)
            }
        }
    }

    async eGetFromIDAsync(featureID: number, resolve: boolean): Promise<any> {
        return this.eGetFromID(featureID, resolve)
    }

    eSetFromID(featureID: number, newValue: any) {
        switch (featureID) {
            case LibraryConstants.DOCUMENT_ROOT__LIBRARY: {
                this.setLibrary(newValue as Library)
                break
            }
            case LibraryConstants.DOCUMENT_ROOT__XMLNS_PREFIX_MAP: {
                const list = this.getXMLNSPrefixMap()
                list.clear()
                list.addAll(newValue as ecore.EList<ecore.EMapEntry<string, string>>)
                break
            }
            case LibraryConstants.DOCUMENT_ROOT__XSI_SCHEMA_LOCATION: {
                const list = this.getXSISchemaLocation()
                list.clear()
                list.addAll(newValue as ecore.EList<ecore.EMapEntry<string, string>>)
                break
            }
            default: {
                super.eSetFromID(featureID, newValue)
            }
        }
    }

    eUnsetFromID(featureID: number) {
        switch (featureID) {
            case LibraryConstants.DOCUMENT_ROOT__LIBRARY: {
                this.setLibrary(null)
                break
            }
            case LibraryConstants.DOCUMENT_ROOT__XMLNS_PREFIX_MAP: {
                this.getXMLNSPrefixMap().clear()
                break
            }
            case LibraryConstants.DOCUMENT_ROOT__XSI_SCHEMA_LOCATION: {
                this.getXSISchemaLocation().clear()
                break
            }
            default: {
                super.eUnsetFromID(featureID)
            }
        }
    }

    eIsSetFromID(featureID: number): boolean {
        switch (featureID) {
            case LibraryConstants.DOCUMENT_ROOT__LIBRARY: {
                return this._library != null
            }
            case LibraryConstants.DOCUMENT_ROOT__XMLNS_PREFIX_MAP: {
                return this._xMLNSPrefixMap && !this._xMLNSPrefixMap.isEmpty()
            }
            case LibraryConstants.DOCUMENT_ROOT__XSI_SCHEMA_LOCATION: {
                return this._xSISchemaLocation && !this._xSISchemaLocation.isEmpty()
            }
            default: {
                return super.eIsSetFromID(featureID)
            }
        }
    }

    eBasicInverseRemove(
        otherEnd: ecore.EObject,
        featureID: number,
        notifications: ecore.ENotificationChain
    ): ecore.ENotificationChain {
        switch (featureID) {
            case LibraryConstants.DOCUMENT_ROOT__LIBRARY: {
                return this.basicSetLibrary(null, notifications)
            }
            case LibraryConstants.DOCUMENT_ROOT__XMLNS_PREFIX_MAP: {
                return notifications
            }
            case LibraryConstants.DOCUMENT_ROOT__XSI_SCHEMA_LOCATION: {
                return notifications
            }
            default: {
                return super.eBasicInverseRemove(otherEnd, featureID, notifications)
            }
        }
    }
}
