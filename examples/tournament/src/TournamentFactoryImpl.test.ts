// Code generated by soft.generator.ts. DO NOT EDIT.

// *****************************************************************************
// Copyright(c) 2024 MASA Group
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
//
// *****************************************************************************

import { describe, expect, test } from "vitest"
import { anything, capture, instance, mock, reset, verify, when } from "ts-mockito"
import * as ecore from "@masagroup/ecore"
import {
    Group,
    Match,
    MatchKind,
    NamedElement,
    Team,
    Tournament,
    TournamentConstants,
    TournamentFactory,
    TournamentFactoryImpl,
    matchKindFromString,
    matchKindToString
} from "./internal.js"

describe("TournamentFactoryImpl", () => {
    test("createFromEClass", () => {
        const factory = TournamentFactoryImpl.getInstance()
        {
            const mockEClass = mock<ecore.EClass>()
            const eClass = instance(mockEClass)
            when(mockEClass.getClassifierID()).thenReturn(-1)
            expect(() => factory.create(eClass)).toThrow(Error)
        }
        {
            const mockEClass = mock<ecore.EClass>()
            const eClass = instance(mockEClass)
            when(mockEClass.getClassifierID()).thenReturn(TournamentConstants.GROUP)
            expect(factory.create(eClass)).not.toBeNull()
        }
        {
            const mockEClass = mock<ecore.EClass>()
            const eClass = instance(mockEClass)
            when(mockEClass.getClassifierID()).thenReturn(TournamentConstants.MATCH)
            expect(factory.create(eClass)).not.toBeNull()
        }
        {
            const mockEClass = mock<ecore.EClass>()
            const eClass = instance(mockEClass)
            when(mockEClass.getClassifierID()).thenReturn(TournamentConstants.TEAM)
            expect(factory.create(eClass)).not.toBeNull()
        }
        {
            const mockEClass = mock<ecore.EClass>()
            const eClass = instance(mockEClass)
            when(mockEClass.getClassifierID()).thenReturn(TournamentConstants.TOURNAMENT)
            expect(factory.create(eClass)).not.toBeNull()
        }
    })

    test("createGroup", () => {
        expect(TournamentFactoryImpl.getInstance().createGroup()).not.toBeNull()
    })

    test("createMatch", () => {
        expect(TournamentFactoryImpl.getInstance().createMatch()).not.toBeNull()
    })

    test("createTeam", () => {
        expect(TournamentFactoryImpl.getInstance().createTeam()).not.toBeNull()
    })

    test("createTournament", () => {
        expect(TournamentFactoryImpl.getInstance().createTournament()).not.toBeNull()
    })

    test("createFromStringInvalid", () => {
        const mockDataType = mock<ecore.EDataType>()
        const eDataType = instance(mockDataType)
        when(mockDataType.getClassifierID()).thenReturn(-1)
        expect(() => TournamentFactoryImpl.getInstance().createFromString(eDataType, "")).toThrow(Error)
    })
    test("convertToStringInvalid", () => {
        const mockDataType = mock<ecore.EDataType>()
        const eDataType = instance(mockDataType)
        when(mockDataType.getClassifierID()).thenReturn(-1)
        expect(() => TournamentFactoryImpl.getInstance().convertToString(eDataType, null)).toThrow(Error)
    })
    test("createMatchKindFromString", () => {
        const factory = TournamentFactoryImpl.getInstance()
        const mockDataType = mock<ecore.EDataType>()
        const eDataType = instance(mockDataType)
        when(mockDataType.getClassifierID()).thenReturn(TournamentConstants.MATCH_KIND)
        expect(factory.createFromString(eDataType, "Final")).toStrictEqual(MatchKind.FINAL)
        expect(factory.createFromString(eDataType, "QuarterFinal")).toStrictEqual(MatchKind.QUARTER_FINAL)
        expect(factory.createFromString(eDataType, "RoundOf16")).toStrictEqual(MatchKind.ROUND_OF16)
        expect(factory.createFromString(eDataType, "RoundOf32")).toStrictEqual(MatchKind.ROUND_OF32)
        expect(factory.createFromString(eDataType, "SemiFinal")).toStrictEqual(MatchKind.SEMI_FINAL)
    })

    test("convertMatchKindToString", () => {
        const factory = TournamentFactoryImpl.getInstance()
        const mockDataType = mock<ecore.EDataType>()
        const eDataType = instance(mockDataType)
        when(mockDataType.getClassifierID()).thenReturn(TournamentConstants.MATCH_KIND)
        expect(factory.convertToString(eDataType, MatchKind.FINAL)).toStrictEqual("Final")
        expect(factory.convertToString(eDataType, MatchKind.QUARTER_FINAL)).toStrictEqual("QuarterFinal")
        expect(factory.convertToString(eDataType, MatchKind.ROUND_OF16)).toStrictEqual("RoundOf16")
        expect(factory.convertToString(eDataType, MatchKind.ROUND_OF32)).toStrictEqual("RoundOf32")
        expect(factory.convertToString(eDataType, MatchKind.SEMI_FINAL)).toStrictEqual("SemiFinal")
    })
})
